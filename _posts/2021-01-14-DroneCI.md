---
layout: post
nav-class: dark
categories: sam
title: Drone CI
author-id: sam
---
# Overview

As of mid-January 2021, a message appears at the top of the travis-ci.org website.

"Please be aware travis-ci.org will be shutting down in several weeks, with all accounts migrating to travis-ci.com. Please stay tuned here for more information."

The transition has not been a smooth one, with long, disruptive delays occurring on existing builds, and lack of clear communication from the company. Many were unaware of the impending change. Some informative posts about the topic are [Extremely poor official communication of the .org shutdown](https://travis-ci.community/t/extremely-poor-official-communication-of-the-org-shutdown/10568) and [Travis CI's new pricing plan threw a wrench in my open source works](https://www.jeffgeerling.com/blog/2020/travis-cis-new-pricing-plan-threw-wrench-my-open-source-works)

The C++ Alliance has decided to implement an in-house CI solution, and to make the new service available for Boost libraries also.

# Selection Process

The first step was choosing which software to use. There are truly a surprising number of alternatives. An extensive review was conducted, including many Continuous Integration services from [awesome-ci](https://github.com/ligurio/awesome-ci) which lists more than 50.  Coincidently, it seems this analysis was already done by Rene Rivera [ci_playground](https://github.com/bfgroup/ci_playground) (and his example config files were the basis for new config files.)

The top choices:  
Appveyor  
Azure Pipelines  
BuildBot  
CircleCI  
CirrusCI  
Drone  
Github Actions  
Semaphore  
Shippable  
TeamCity  

From this list, Appveyor and Drone seemed promising to start with, and both allowed for 100% self-hosting. Those would be tested first.  

## Appveyor

The appeal of Appveyor is that the config files are basic yaml, and everything runs in a Docker container. It sounds perfect. However, after experimentation there were a few issues.  
1. Appveyor was originally designed for Microsoft Windows, with .NET and Powershell being key ingredients. While it can run on Linux also, it's not a native Linux application.  
2. The Docker experience on Windows is not nearly as smooth as Linux. I encountered numerous complexities when setting up Appveyor Windows Docker containers.  
3. Discovered and reported some UI bugs in their app.

Mainly, the idea of maintaining and operating a Windows app, which is running on Linux, was one of the main drawbacks.  

## Drone

Within the first day or two experimenting with Drone, it became clear that this was an excellent choice.  
1. Linux and Docker native  
2. Simple, usable UI  
3. Easy installation  
4. Few moving parts  
5. Integrates with MySQL, Postgres, Amazon S3  
6. Autoscale the agents  
7. Badges on github repos  

The main drawback for Drone was the absence of matrix builds for the yaml config files. Their alternative for matrices was jsonnet or starlark, which are flexible scripting languages. I was apprehensive about this point, thinking that the end-users would prefer simple yaml files - exactly like Travis. And, in fact, that is still probably the case. A basic yaml files are easier to understand. However, on balance, this was the only apparent problem with Drone, and everything else seemed to be in order.  

To discuss [Starlark](https://docs.bazel.build/versions/master/skylark/language.html) for a moment - this language is a subset of python.  

[Why would I use this instead of just Python?](https://pypi.org/project/pystarlark/)"Sandboxing. The primary reason this was written is for the "hermetic execution" feature of Starlark. Python is notoriously difficult to sandbox and there didn't appear to be any sandboxing solutions that could run within Python to run Python or Python-like code. While Starlark isn't exactly Python it is very very close to it. You can think of this as a secure way to run very simplistic Python functions. Note that this library itself doesn't really provide any security guarantees and your program may crash while using it (PRs welcome). Starlark itself is providing the security guarantees."  

### Running a drone server. 

Create script startdrone.sh with these contents:
```
#!/bin/bash
  
docker run \
  --volume=/var/lib/drone:/data \
  --env=DRONE_GITHUB_CLIENT_ID= \
  --env=DRONE_GITHUB_CLIENT_SECRET= \
  --env=DRONE_RPC_SECRET= \
  --env=DRONE_TLS_AUTOCERT= \
  --env=DRONE_SERVER_HOST= \
  --env=DRONE_SERVER_PROTO= \
  --env=DRONE_CONVERT_PLUGIN_ENDPOINT= \
  --env=DRONE_CONVERT_PLUGIN_SECRET= \
  --env=DRONE_HTTP_SSL_REDIRECT= \
  --env=DRONE_HTTP_SSL_TEMPORARY_REDIRECT= \
  --env=DRONE_S3_BUCKET= \
  --env=DRONE_LOGS_PRETTY= \
  --env=AWS_ACCESS_KEY_ID= \
  --env=AWS_SECRET_ACCESS_KEY= \
  --env=AWS_DEFAULT_REGION= \
  --env=AWS_REGION= \
  --env=DRONE_DATABASE_DRIVER= \
  --env=DRONE_DATABASE_DATASOURCE= \
  --env=DRONE_USER_CREATE= \
  --env=DRONE_REPOSITORY_FILTER= \
  --env=DRONE_GITHUB_SCOPE= \
  --publish=80:80 \
  --publish=443:443 \
  --restart=always \
  --detach=true \
  --name=drone \
  drone/drone:1
```

Fill in the variables. (Many of those are keys which shouldn't be published on a public webpage.) Then, run the script.  

```
./startdrone.sh  
```

Drone is up and running.  

Next, the starlark plugin. Edit startstarlark.sh:  
```
#!/bin/bash
  
docker run -d \
  --volume=/var/lib/starlark:/data \
  --env= \
  --publish= \
  --env=DRONE_DEBUG= \
  --env=DRONE_SECRET= \
  --restart=always \
  --name=starlark drone/drone-convert-starlark
```
and run it:  

```
./startstarlark.sh
```

Starlark is up and running.  
Finally, the autoscaler.  
```
#!/bin/bash
  
docker run -d \
  -v /var/lib/autoscaler:/data \
  -e DRONE_POOL_MIN= \
  -e DRONE_POOL_MAX= \
  -e DRONE_SERVER_PROTO= \
  -e DRONE_SERVER_HOST= \
  -e DRONE_SERVER_TOKEN= \
  -e DRONE_AGENT_TOKEN= \
  -e DRONE_AMAZON_REGION= \
  -e DRONE_AMAZON_SUBNET_ID= \
  -e DRONE_AMAZON_SECURITY_GROUP= \
  -e AWS_ACCESS_KEY_ID= \
  -e AWS_SECRET_ACCESS_KEY= \
  -e DRONE_CAPACITY_BUFFER= \
  -e DRONE_REAPER_INTERVAL= \
  -e DRONE_REAPER_ENABLED= \
  -e DRONE_ENABLE_REAPER= \
  -e DRONE_AMAZON_INSTANCE= \
  -e DRONE_AMAZON_VOLUME_TYPE= \
  -e DRONE_AMAZON_VOLUME_IOPS= \
  -p  \
  --restart=always \
  --name=autoscaler \
  drone/autoscaler
```
Start the autoscaler.  
```
./startautoscaler.sh
```

Now everything is running. Not too difficult. The real complexities appear when setting up setting up all the config files. After manually porting .travis.yml from https://github.com/boostorg/beast and https://github.com/boostorg/json, the next step was to create a Python script to automated that process.  

A copy of the script can be viewed at https://github.com/CPPAlliance/droneconverter-demo  



